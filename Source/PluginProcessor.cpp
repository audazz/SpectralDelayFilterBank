/*
==============================================================================

This file was auto-generated by the Jucer!

It contains the basic startup code for a Juce application.

==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "FilterCoeffs.h"

//==============================================================================
SpectralDelayPluginAudioProcessor::SpectralDelayPluginAudioProcessor()
{
	//set the FFT size and number of filters
	N = 4096;
	numFilters = 5;
	filterVector.resize(numFilters);
	delayLineVector.resize(numFilters);
	delayAmounts.resize(numFilters);
	//create filter objects and store them in the filter vector and create delay lines and store them in the delaylineVector
	for(int i = 0; i < numFilters; ++i)
	{
		filterVector[i] = new FFTfilter(filters_real[i], filters_imag[i], filter_orders[i], N);
		delayLineVector[i] = new CircularBuffer<double>();
	}

	delayAmounts[0] = 0 + phase_offsets[0];
	delayAmounts[1] = 8820 + phase_offsets[1];
	delayAmounts[2] = 11025 + phase_offsets[2];
	delayAmounts[3] = 12128 + phase_offsets[3];
	delayAmounts[4] = 13230 + phase_offsets[4];
}

SpectralDelayPluginAudioProcessor::~SpectralDelayPluginAudioProcessor()
{
}

//==============================================================================
const String SpectralDelayPluginAudioProcessor::getName() const
{
	return JucePlugin_Name;
}

int SpectralDelayPluginAudioProcessor::getNumParameters()
{
	return totalNumParams;
}

float SpectralDelayPluginAudioProcessor::getParameter (int index)
{
	//as parameters are expected to be floats in the range from 0.0 - 1.0, map the values in delayAmounts (stored as delay in samples) to this range
	switch(index)
	{
	case f0_delayParam:
		return static_cast<float>(delayAmounts[1]) / maxSampleDelay;
	case f1_delayParam:
		return static_cast<float>(delayAmounts[1]) / maxSampleDelay;
	case f2_delayParam:
		return static_cast<float>(delayAmounts[2]) / maxSampleDelay;
	case f3_delayParam:
		return static_cast<float>(delayAmounts[3]) / maxSampleDelay;
	case f4_delayParam:
		return static_cast<float>(delayAmounts[4]) / maxSampleDelay;
	default:
		return 0.0f;
	}
}

void SpectralDelayPluginAudioProcessor::setParameter (int index, float newValue)
{
	//as newValue is in the range from 0 - 1.0 it needs to be mapped to 0 - maxSampleDelay and stored as an int as it corresponds to delay in samples keeping in mind the delay buffers begin indexing at 0	
	int mappedValue = newValue * maxSampleDelay - 1;	
	switch(index)
	{
	case f0_delayParam:
		delayAmounts[0] = mappedValue;
		break;
	case f1_delayParam:
		delayAmounts[1] = mappedValue;
		break;
	case f2_delayParam:
		delayAmounts[2] = mappedValue;
		break;
	case f3_delayParam:
		delayAmounts[3] = mappedValue;
		break;
	case f4_delayParam:
		delayAmounts[4] = mappedValue;
		break;
	default:
		break;
	}
}

const String SpectralDelayPluginAudioProcessor::getParameterName (int index)
{
	switch(index)
	{
	case f0_delayParam:
		return "Filter 0 delay";
	case f1_delayParam:
		return "Filter 1 delay";
	case f2_delayParam:
		return "Filter 2 delay";
	case f3_delayParam:
		return "Filter 3 delay";
	case f4_delayParam:
		return "Filter 4 delay";
	default:
		return String::empty;
	}
}

const String SpectralDelayPluginAudioProcessor::getParameterText (int index)
{
	return String(getParameter(index), 2);
}

const String SpectralDelayPluginAudioProcessor::getInputChannelName (int channelIndex) const
{
	return String (channelIndex + 1);
}

const String SpectralDelayPluginAudioProcessor::getOutputChannelName (int channelIndex) const
{
	return String (channelIndex + 1);
}

bool SpectralDelayPluginAudioProcessor::isInputChannelStereoPair (int index) const
{
	return true;
}

bool SpectralDelayPluginAudioProcessor::isOutputChannelStereoPair (int index) const
{
	return true;
}

bool SpectralDelayPluginAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
	return true;
#else
	return false;
#endif
}

bool SpectralDelayPluginAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
	return true;
#else
	return false;
#endif
}

int SpectralDelayPluginAudioProcessor::getNumPrograms()
{
	return 0;
}

int SpectralDelayPluginAudioProcessor::getCurrentProgram()
{
	return 0;
}

void SpectralDelayPluginAudioProcessor::setCurrentProgram (int index)
{
}

const String SpectralDelayPluginAudioProcessor::getProgramName (int index)
{
	return String::empty;
}

void SpectralDelayPluginAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void SpectralDelayPluginAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
	// Use this method as the place to do any pre-playback
	// initialisation that you need..
	maxSampleDelay = sampleRate*2;

	//resize and clear delay lines
	for(int i = 0; i < numFilters; ++i)
	{
		CircularBuffer<double>& currentDelayLine = *(delayLineVector[i]);
		currentDelayLine.changeSize(maxSampleDelay + phase_offsets[i]);
		for(int j = 0; j < maxSampleDelay + phase_offsets[i]; ++j)
		{
			currentDelayLine[j] = 0.0;
		}
	}
}

void SpectralDelayPluginAudioProcessor::releaseResources()
{
	// When playback stops, you can use this as an opportunity to free up any
	// spare memory, etc.
}

//this plugin can only handle one channel of input and has only one channel of output
void SpectralDelayPluginAudioProcessor::processBlock (AudioBuffer<float>& buffer, MidiBuffer& midiMessages)
{
	// This is the place where you'd normally do the guts of your plugin's
	// audio processing...
	int numSamples = buffer.getNumSamples();
	ScopedPointer<double> doubleInput = new double[numSamples];
	ScopedPointer<double> doubleOutput = new double[numSamples];
	ScopedPointer<float> functionOutput = new float[numSamples];
	// ..do something to the data...
	float* channelData = buffer.getWritePointer (0);
	//convert input data to doubles for now, ask on forums if it's possible use use doubles instead w/ AudioSampleBuffer otherwise rewrite filter's to use floats instead (maybe make a template for different numeric types)
	for(int i = 0; i < numSamples; ++i)
	{
		doubleInput[i] = channelData[i];
		functionOutput[i] = 0.0;
	}

	for(int i = 0; i < numFilters; ++i)
	{
		FFTfilter& currentFilter = *(filterVector[i]);
		CircularBuffer<double>& currentDelayLine = *(delayLineVector[i]);
		currentFilter.filter(doubleInput, doubleOutput, numSamples);
		//copy filter output to the correct delay line and copy to the function's output at the same time
		for(int j = 0; j < numSamples; ++j)
		{
			currentDelayLine.addData(doubleOutput[j]);
			functionOutput[j] += float(currentDelayLine[delayAmounts[i]]);
		}
	}
	//clear the buffer and copy the output data to it
	buffer.clear();
	buffer.copyFrom(0, 0, functionOutput, numSamples);
}

//==============================================================================
bool SpectralDelayPluginAudioProcessor::hasEditor() const
{
	return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* SpectralDelayPluginAudioProcessor::createEditor()
{
	return new SpectralDelayPluginAudioProcessorEditor (*this);
}

//==============================================================================
void SpectralDelayPluginAudioProcessor::getStateInformation (MemoryBlock& destData)
{
	// You should use this method to store your parameters in the memory block.
	// You could do that either as raw data, or use the XML or ValueTree classes
	// as intermediaries to make it easy to save and load complex data.
}

void SpectralDelayPluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
	// You should use this method to restore your parameters from this memory block,
	// whose contents will have been created by the getStateInformation() call.
}

void SpectralDelayPluginAudioProcessor::reset()
{
	// Use this method as the place to clear any delay lines, buffers, etc, as it
    // means there's been a break in the audio's continuity.
	for(int i = 0; i < numFilters; ++i)
	{
		FFTfilter& currentFilter = *(filterVector[i]);
		CircularBuffer<double> currentBuffer = *(delayLineVector[i]);
		currentFilter.clearBuffer();
		currentBuffer.clearContents();
	}
}


bool SpectralDelayPluginAudioProcessor::isMidiEffect() const
{
#if JucePlugin_IsMidiEffect
    return true;
#else
    return false;
#endif
}

double SpectralDelayPluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
	return new SpectralDelayPluginAudioProcessor();
}

